<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
    <meta charset="utf-8">
    <title>Liferinth.js</title>
    <script src="js/babylon.js"></script>
    <script src="js/hand.js"></script>
    <style>
        html, body {
            width: 100%;
            height: 100%;
            padding: 0;
            margin: 0;
            overflow: hidden;
        }

        #renderCanvas {
            width: 100%;
            height: 100%;
        }
    </style>
	<script>
		/** Global variables **/
		var cpu,gpu,speedSetting,rowsSettings,columnsSettings;
		//----------------------------------------------------------------------------------------------------
		/** Obtiene las variables que se pasan como parámetros en la URL **/
		function getUrlVars() {
			var vars = {};
			var parts = window.location.href.replace(/[?&]+([^=&]+)=([^&]*)/gi, function(m,key,value) {
				vars[key] = value;
			});
			return vars;
		}
		//-----------------------------------------------------------------------------------------------------
		/** Carga las opciones que previamente han sido seleccionadas en el menú **/
		function loadSettings()
		{
			cpu = getUrlVars()["C"];
			gpu = getUrlVars()["G"];
			speedSetting = getUrlVars()["S"];
			rowsSettings = getUrlVars()["R"];
			columnsSettings = getUrlVars()["Co"];
			
			/**
			Values
				cpu:				"green","red"
				gpu:				"green","red"
				speedSetting: 		"l"(Low),"n"(Normal),"h"(high)
				rowsSettings:  		"f"(Few),"n"(Normal),"m"(many)
				columns:			"f"(Few),"n"(Normal),"m"(many)
			**/
			if(cpu == "undefined" )
			{
				cpu = "green";
				gpu = "green";
				speedSetting = "n"; 	//Normal
				rowsSettings = "n";		//Normal
				columnsSettings = "n";	//Normal
			}
		}
		
	</script>
</head>
<body onload="loadSettings()">
    <canvas id="renderCanvas"></canvas>
    <script>
        if (BABYLON.Engine.isSupported()) {

            /*Estado del muro: 
                0 : No hay muro creado
                1 : Muro activo
                2 : Muro no visible
                3 : Muro permanente (no bajará el muro nunca)
                4 : Hueco permanente (no habrá muro en esa posición)
            */
            var WallState = { NonExisting: 0, Alive: 1, Dead: 2, PermaWall: 3, PermaGap: 4 }

			loadSettings();

		    var canvas = document.getElementById("renderCanvas");
            var engine = new BABYLON.Engine(canvas, true);
            var scene = new BABYLON.Scene(engine);
            var imported = new BABYLON.Scene(engine);

			var meshPlayer, collidingBox,turnLeft=false,turnRight=false,forward=false,backwards=false;
			var jumping = false; var crouching = false;

			var rows;
			switch (rowsSettings) {
			    case "m":
			        rows = 30;
			        break;
			    case "n":
			        rows = 20;
			        break;
			    case "f":
			        rows = 10;
			        break;
			    default:
			        rows = 20;
			        break;
			}
			var lastRow = rows-2; //Por cómo está hecha la matriz, esta es la última fila de la matriz de muros
			var cols;
			switch (columnsSettings) {
			    case "m":
			        cols = 30;
			        break;
			    case "n":
			        cols = 20;
			        break;
			    case "f":
			        cols = 10;
			        break;
			    default:
			        cols = 20;
			        break;
			}
			var lastCol = cols - 1;
			var timeChange;
			switch (speedSetting) {
			    case "h":
			        timeChange = 2;
			        break;
			    case "n":
			        timeChange = 4;
			        break;
			    case "l":
			        timeChange = 8;
			        break;
			    default:
			        timeChange = 4;
			        break;
			}

			var alturaSuelo = 0;
			var planeSize = 500;

			var margen = 1.01;

			var alturaPlayer = 1.75;
			var anchuraPlayer = 0.5;
			var longitudPlayer = 0.5;
			var ellipsoidPlayer = new BABYLON.Vector3(0.5, alturaPlayer / 4, 0.5);

			var anchuraMuro = 6;
			var alturaMuro = 4;
			var profundidadMuro = 0.75;
			var scaleMuro = new BABYLON.Vector3(profundidadMuro, alturaMuro, anchuraMuro);

			var gravity = new BABYLON.Vector3(0, -9, 0);

			var speed = 0.14;                   // Velocidad del jugador
			var speedReduceCrouching = 0.4;     // Velocidad del jugador agachado
			var backSpeed = -0.07;              // Velocidad del jugador retrocediendo

			var activeFlashlight = true;
			var topDownCameraHeight = 40;       // Altura de la cámara topdown
			var activeCamera = 0;               // 0 = FollowCam, 1 = TopDownCamera
			var numCameras = 2;                 // Número de cámaras

            //Variables del salto: Altura del salto, tiempo de vuelo
			var jumpHeight = 1.5;
            var jumpTime = 0.3;

			function CreateMatrix(rows,cols) {
			  var arr = [];

			  for (var i=0;i<rows;i++) {
				 arr[i] = []; //Vacío
				 for (var j=0;j<cols;j++) {
					arr[i][j] = 0;
				 }
			  }

			  return arr;
			}


			function CreateDefaultWall(){
				var box = BABYLON.Mesh.CreateBox("Box", 1.0, scene);

				var FrontMaterial = new BABYLON.StandardMaterial("cubeFront", scene);
				FrontMaterial.diffuseTexture = new BABYLON.Texture("images/MetalWallReplica2.png", scene);
				FrontMaterial.diffuseTexture.wAng += Math.PI * 0.5;

				FrontMaterial.diffuseTexture.uScale = 1;
				FrontMaterial.diffuseTexture.vScale = 1;
			    /*
				var BackMaterial = new BABYLON.StandardMaterial("cubeBack", scene);
				BackMaterial.diffuseTexture = new BABYLON.Texture("images/MuroFront.png", scene);
				BackMaterial.diffuseTexture.wAng += Math.PI*0.5;

				var LeftMaterial = new BABYLON.StandardMaterial("cubeLeft", scene);
				LeftMaterial.diffuseTexture = new BABYLON.Texture("images/MuroLat.png", scene);
				LeftMaterial.diffuseTexture.wAng += Math.PI*0.5;

				var RightMaterial = new BABYLON.StandardMaterial("cubeRight", scene);
				RightMaterial.diffuseTexture = new BABYLON.Texture("images/MuroLat.png", scene);
*/
				var cubeMultiMat = new BABYLON.MultiMaterial("cubeMulti", scene);
				cubeMultiMat.subMaterials.push(FrontMaterial);

				/*cubeMultiMat.subMaterials.push(BackMaterial);
				cubeMultiMat.subMaterials.push(LeftMaterial);
				cubeMultiMat.subMaterials.push(RightMaterial);*/
                /*
				box.subMeshes = [];
				box.subMeshes.push(new BABYLON.SubMesh(2, 0,  4,  0, 6, box));  //Detrás
				box.subMeshes.push(new BABYLON.SubMesh(3, 4,  4,  6, 6, box));	//Delante
				box.subMeshes.push(new BABYLON.SubMesh(0, 8,  4, 12, 6, box));	//Derecha
				box.subMeshes.push(new BABYLON.SubMesh(1, 12, 4, 18, 6, box));	//Izquierda
 
				box.subMeshes.push(new BABYLON.SubMesh(2, 16, 4, 24, 6, box));	//Arriba
				box.subMeshes.push(new BABYLON.SubMesh(3, 20, 4, 30, 6, box));	//Abajo
                */

				box.material = cubeMultiMat;
				box.checkCollisions = true;
				box.scaling = scaleMuro;
				return box;
			}

			function CreateWall(i, j, even) { // i = fila, j = columna, even = par (si es horizontal o vertical)
			    paintedWalls[i][j] = CreateDefaultWall();
			    paintedWalls[i][j].position = posMatrix[i][j];
			    walls[i][j] = WallState.Alive;
			    AnimateWall(i, j);
			    if (even) paintedWalls[i][j].rotation.y = 0.5 * Math.PI;
			}

			function RandomWallMatrix() {
			    var randomWallMatrix = [];
			    var c = cols;
			    for (var i = 0; i < (lastRow+1);i++){
			        randomWallMatrix[i] = [];
			        var even = (i % 2 == 0);
			        if (even) c--; //Las filas pares son muros horizontales, hay una columna menos
			        else c++;

			        for (var j = 0; j < c; j++){
			            if (Math.floor(Math.random() * 10) <= 3)
			                //if( ((i+j)*7)%3 == 0)
			                randomWallMatrix[i][j] = WallState.Alive;
			            else randomWallMatrix[i][j] = WallState.NonExisting;
			        }
			    }
			    return randomWallMatrix;
			}

			function PositionsMatrix(rows,cols){
				var even = true;
				var positionMatrix = CreateMatrix(rows,cols);

				var zIni = (anchuraMuro/2) + anchuraMuro* (rows/2); //Cada celda está separada por 4 de distancia y vamos a empezar por el origen (centro del laberinto)
				var xIni = - anchuraMuro* (cols/2);
				var yIni = alturaSuelo+alturaMuro/2;
				var zAct = zIni;

				for (var i = 0; i< (lastRow+1); i++){

					var xAct = xIni;
					if (!even) xAct -= (anchuraMuro/2); //Filas pares horizontales, impares verticales

					for(var j= 0; j< cols; j++){
					    positionMatrix[i][j] = new BABYLON.Vector3(xAct, yIni, zAct);
						xAct += anchuraMuro;
					}
					even = !even;
					zAct -= (anchuraMuro/2);

				}
				return positionMatrix;
			}

			function CreateBorder() {
			    for (var i = 0; i < (lastRow) ; i++) 
                    if((i%2)==1){
                        walls[i][0] = WallState.PermaWall; 
                        walls[i][lastCol] = WallState.PermaWall; 
                    }
			    for (var j = 0; j < (lastCol) ; j++) {
			        walls[0][j] = WallState.PermaWall;
			        walls[lastRow][j] = WallState.PermaWall;
			    }
			}

			function CreateEntranceAndExit(entranceCol,exitCol) {
			    walls[lastRow][entranceCol] = WallState.PermaGap;
			    walls[0][exitCol] = WallState.PermaGap;
			}

			function CreateLabyrinthBounding(entranceCol,exitCol) {
			    CreateBorder();
			    CreateEntranceAndExit(entranceCol,exitCol);
			}

			function PaintWalls(walls,rows,cols){ //Devuelve un array de nodos Array tipo "objeto muro, fila, columna"
				var paintedWalls = [];
				for (var i = 0; i < (lastRow+1);i++){
				    paintedWalls[i] = [];
				    var even = (i % 2 == 0);
				    if (even) cols--; //Las filas pares son muros horizontales, hay una columna menos
					else cols++;

					for (var j = 0; j < cols; j++){
					    if ((walls[i][j] == WallState.Alive) || (walls[i][j] == WallState.PermaWall)) {
						    paintedWalls[i][j] = CreateDefaultWall();
							paintedWalls[i][j].position = posMatrix[i][j];
							if (even) paintedWalls[i][j].rotation.y = 0.5 * Math.PI;
						}
					}
				}
				return paintedWalls;
			}

			function AnimateWall(r, c) {
			    var string1 = "animation " + r + " " + c;
			    var animationBox = new BABYLON.Animation(string1, "position.y", 75,
                    BABYLON.Animation.ANIMATIONTYPE_FLOAT, BABYLON.Animation.ANIMATIONLOOPMODE_CYCLE);
			    // An array with all animation keys
			    var keys = [];

			        keys.push({
			            frame: 0,
			            value: alturaSuelo + alturaMuro / 2
			        });
			        keys.push({
			            frame: 20,
			            value: alturaSuelo
			        });
			        keys.push({
			            frame: 100,
			            value: alturaSuelo - (alturaMuro * margen) / 2
			        });
			        keys.push({
			            frame: 120,
			            value: alturaSuelo + alturaMuro / 4
			        });
			        keys.push({
			            frame: 200,
			            value: alturaSuelo + alturaMuro / 2
			        });
			    animationBox.setKeys(keys);
			    paintedWalls[r][c].animations.push(animationBox);
			}

			function AnimatePlayer() {
			    var string1 = "Player position";
			    var animationPosition = new BABYLON.Animation(string1, "position.y", 100/jumpTime,
                    BABYLON.Animation.ANIMATIONTYPE_FLOAT, BABYLON.Animation.ANIMATIONLOOPMODE_CYCLE);
			    // An array with all animation keys
			    var keys = [];

			    // 0-100 Animación salto
                // 100-200 Animación aterrizaje
			    keys.push({
			        frame: 0,
			        value: alturaSuelo + alturaPlayer / 2
			    });
			    keys.push({
			        frame: 55,
			        value: alturaSuelo + alturaPlayer / 2 + jumpHeight*(3/4)
			    });
			    keys.push({
			        frame: 100,
			        value: alturaSuelo + alturaPlayer / 2 + jumpHeight
			    });
			    keys.push({
			        frame: 140,
			        value: alturaSuelo + alturaPlayer / 2 + jumpHeight*(3/4)
			    });
			    keys.push({
			        frame: 200,
			        value: alturaSuelo + alturaPlayer / 2
			    });
			    keys.push({
			        frame: 250,
			        value: alturaSuelo + alturaPlayer / 3
			    });
			    keys.push({
			        frame: 300,
			        value: alturaSuelo + alturaPlayer / 2
			    });

			    animationPosition.setKeys(keys);

			    // An array with all animation keys
			    var keys2 = [];
			    var string2 = "Player scaling";
			    var animationCrouch = new BABYLON.Animation(string2, "scaling.y", 100/jumpTime,
                    BABYLON.Animation.ANIMATIONTYPE_FLOAT, BABYLON.Animation.ANIMATIONLOOPMODE_CYCLE);
			    // 200-250 Animación agacharse
			    // 250-300 Animación levantarse
			    keys2.push({
			        frame: 200,
			        value: alturaPlayer
			    });
			    keys2.push({
			        frame: 250,
			        value: alturaPlayer * (2/3)
			    });
			    keys2.push({
			        frame: 300,
			        value: alturaPlayer
			    });
			    animationCrouch.setKeys(keys2);

			    collidingBox.animations.push(animationPosition);
			    collidingBox.animations.push(animationCrouch);
			    

			}
			function JumpAnimation() {
			    scene.beginAnimation(collidingBox, 0, 100, false);
			}
			function LandAnimation() {
			    scene.beginAnimation(collidingBox, 100, 200, false);
			}
			function CrouchAnimation() {
			    scene.beginAnimation(collidingBox, 200, 250, false);
			    collidingBox.ellipsoid = new BABYLON.Vector3(0.5, (alturaPlayer*(2/3))/ 4, 0.5);
			}
			function StandUpAnimation() {
			    crouching = false;
			    scene.beginAnimation(collidingBox, 250, 300, false);
			    collidingBox.ellipsoid = ellipsoidPlayer;
			}

			function AnimateWalls() {
			    var c = cols;
			    for (var i = 0; i < (lastRow+1) ; i++) {
			        if((i%2) == 0) c--;
			        else c++;
			        for (var j = 0; j < c; j++) {
			            if ((walls[i][j] == WallState.Alive) || (walls[i][j] == WallState.Dead)) {
			                AnimateWall(i, j);
			            }
                    }
			    }
			}

			function HideAnimation(r, c) {
			    scene.beginAnimation(paintedWalls[r][c], 0, 100, false);
			}
			function ShowAnimation(r, c) {
			    scene.beginAnimation(paintedWalls[r][c], 100, 200, false);
			}


			function HideWall(row, col) {
			    if (walls[row][col] == WallState.Alive) { //Si está vivo
			        walls[row][col] = WallState.Dead;			        
			        window.setTimeout(function () { paintedWalls[row][col].checkCollisions = false; }, 1.1 * 1000);
			        //paintedWalls[row][col].visibility = false;
			        HideAnimation(row,col);
			    }
			}

			function ShowWall(row, col) {
			    if (walls[row][col] == WallState.Dead) { //Si está muerto, resucitamos
			        walls[row][col] = WallState.Alive;
			        paintedWalls[row][col].checkCollisions = true;
			        //paintedWalls[row][col].visibility = true;
			        ShowAnimation(row,col);
			    }
			}

			function AliveNeighbours8(w,row, col) { //Recibe muro (fila y columna) y devuelve el número de vecinos vivos (muros activos) en 8-vecindad
			    var n = 0;
			    var pasadas = 0;
			    var state;
			    for (var i = row-1; i <= row+1; i++)
			        for (var j = col - 1; j <= col + 1; j++) 
			            if (!(i == row && j == col))    //No somos nosotros mismos
			                if (i >= 0 && i <= lastRow && j >= 0 && j < lastCol) { //No nos salimos de rango
			                    state = w[i][j];
			                    if ((state == WallState.Alive) || (state == WallState.PermaWall))
			                        n++;
			                }
			    return n;

			}

			function CopyWalls() { //Devuelve una copia de la matriz walls
			    var w = [];
			    var c = cols;
			    for (var i = 0; i < (lastRow + 1) ; i++) {
			        w[i] = [];
			        var even = ((i % 2) == 0);
			        if (even) c--;
			        else c++;
			        for (var j = 0; j < c; j++) {
			            w[i][j] = walls[i][j];
			        }
			    }
			    return w;
			}

			function UnderneathPlayer(row,col,even) {
			    var under = false;
			    var xPlayer = meshPlayer.position.x;
			    var zPlayer = meshPlayer.position.z;
			    var mismoPlano = true; /// TODO Si hay varios niveles de laberinto, diferenciar
			    var xWallMin,xWallMax,zWallMin,zWallMax;
			    var xWall = posMatrix[row][col].x;
			    var zWall = posMatrix[row][col].z;
			    if(even){
			        xWallMin = xWall - anchuraMuro;
			        xWallMax = xWall + anchuraMuro;
			        zWallMin = zWall - profundidadMuro;
			        zWallMax = zWall + profundidadMuro;
			    }else{
			        xWallMin = xWall - profundidadMuro;
			        xWallMax = xWall + profundidadMuro;
			        zWallMin = zWall - anchuraMuro;
			        zWallMax = zWall + anchuraMuro;
			    }
			    if (mismoPlano && (xPlayer < xWallMax) && (xPlayer > xWallMin) && (zPlayer < zWallMax) && (zPlayer > zWallMin))
			        under = true;
			    return under;
			}

			function ChangeWallsLife() {
			    var w = CopyWalls(); //Necesitamos tener una matriz estática hasta pasar una generación para no influir con cambios sucesivos en la misma

			    var c = cols;
			    for (var i = 0; i < (lastRow + 1) ; i++) {
			        var even = ((i % 2) == 0);
			        if (even) c--;
			        else c++;
			        for (var j = 0; j < c; j++) {
			                var n = AliveNeighbours8(w, i, j);
			                if (n == 3 && !UnderneathPlayer(i, j, even) ){  //Genera vida
			                    if (walls[i][j] == WallState.Dead)
			                            ShowWall(i, j);
			                    else if (walls[i][j] == WallState.NonExisting) {
			                        CreateWall(i, j, even);
			                        ShowAnimation(i, j);
			                    }
			                }
			                else if ((n > 3) && (walls[i][j] == WallState.Alive)) { //Muerte por inanición 
			                    HideWall(i, j);
			                }
			                else if ((n < 2) && (walls[i][j] == WallState.Alive)) { //Muerte por aislamiento
			                    HideWall(i, j);
			                }
			        }
			    }
			}

			function ChangeWalls() {
			    var c = cols;
			    for (var i = 0; i < (lastRow+1); i++){
			        var even = ((i % 2) == 0);
			        if (even) c--;
			        else c++;
			        for (var j = 0; j < c; j++) {  
			            if (walls[i][j] == WallState.Alive){
			                if (Math.floor(Math.random() * 10) <= 1)
			                    HideWall(i, j);
			            } else if (!UnderneathPlayer(i, j, even)) {
			                if (walls[i][j] == WallState.Dead) {
			                    if (Math.floor(Math.random() * 10) <= 1)
			                        ShowWall(i, j);
			                } else if (walls[i][j] == WallState.NonExisting) {
			                    if (Math.floor(Math.random() * 10) <= 1) {
			                        CreateWall(i, j, even);
			                        ShowAnimation(i, j);
			                    }
			                }
			            }
			        }
			    }
			}

			function Land() {
			    LandAnimation();
			    window.setTimeout(function () { jumping = false; }, jumpTime * 1000);
			}



			var posMatrix = PositionsMatrix(rows,cols);
			var walls = RandomWallMatrix();
            CreateLabyrinthBounding(cols/2,cols/2);
			var paintedWalls = PaintWalls(walls, rows, cols);
			AnimateWalls();

			window.setInterval(ChangeWallsLife, timeChange*1000);

            //Jugador
			    meshPlayer = BABYLON.Mesh.CreateBox("player", 1, scene);
			    collidingBox = BABYLON.Mesh.CreateBox("colPlayer", 1, scene);
			    meshPlayer.scaling = new BABYLON.Vector3(anchuraPlayer, alturaPlayer, longitudPlayer);
			    collidingBox.scaling = new BABYLON.Vector3(anchuraPlayer, alturaPlayer, longitudPlayer);
			    meshPlayer.position.y = alturaSuelo + (meshPlayer.scaling.y / 2);
			    collidingBox.position.y = meshPlayer.position.y;
			    collidingBox.checkCollisions = true;
			    collidingBox.applyGravity = true;
			    collidingBox.ellipsoid = ellipsoidPlayer;
			    AnimatePlayer();
			    collidingBox.showBoundingBox=true;

			//Luces

				//var light0 = new BABYLON.PointLight("Omni0", new BABYLON.Vector3(0, 100, 100), scene);

                 //Direccional
                /*
				var light0 = new BABYLON.DirectionalLight("Dir0", new BABYLON.Vector3(-0.5, -0.4, 0.5), scene);
				light0.diffuse = new BABYLON.Color3(1, 1, 1);
				light0.specular = new BABYLON.Color3(1, 1, 1);
				light0.position = new BABYLON.Vector3(20, 40, 20);

				var light1 = new BABYLON.DirectionalLight("Dir1", new BABYLON.Vector3(0.3, -0.4, -0.3), scene);
				light1.diffuse = new BABYLON.Color3(0.3, 0.3, 0.3);
				light1.specular = new BABYLON.Color3(1, 1, 1);
                */
				//Hemisférica
				var light1 = new BABYLON.HemisphericLight("Hemi0", new BABYLON.Vector3(0, 1, 0), scene);
				light1.diffuse = new BABYLON.Color3(0.1, 0.1, 0.1);
				light1.specular = new BABYLON.Color3(0.2, 0.2, 0.2);
				light1.groundColor = new BABYLON.Color3(0, 0, 0);
                //Hemisférica 2
				var light2 = new BABYLON.HemisphericLight("Hemi0", new BABYLON.Vector3(0, -1, 0), scene);
				light2.diffuse = new BABYLON.Color3(0.1, 0.1, 0.1);
				light2.specular = new BABYLON.Color3(0.2, 0.2, 0.2);
				light2.groundColor = new BABYLON.Color3(0, 0, 0);

				//Spot
			/*	
			    var light2 = new BABYLON.SpotLight("Spot0", new BABYLON.Vector3(meshPlayer.position.x, meshPlayer.position.y + (meshPlayer.scaling.y / 2) * margen, meshPlayer.position.z),
                    new BABYLON.Vector3(meshPlayer.rotation.x, -0.01, meshPlayer.rotation.z), 2.2, 2, scene);
				light2.diffuse = new BABYLON.Color3(0.7, 0.7, 0.7);
				light2.specular = new BABYLON.Color3(1, 1, 1);
            */
			    var angFlashlight = -0.4;
			    var flashlight = new BABYLON.SpotLight("Flashlight", new BABYLON.Vector3(meshPlayer.position.x, meshPlayer.position.y + (meshPlayer.scaling.y / 2) * margen, meshPlayer.position.z),
                    new BABYLON.Vector3(Math.sin(meshPlayer.rotation.y), angFlashlight, Math.cos(meshPlayer.rotation.y)), 3, 3, scene);
			        //new BABYLON.Vector3(-0.5, -0.2, 0.4), 3, 3, scene);
				flashlight.diffuse = new BABYLON.Color3(0.7, 0.7, 0.7);
				flashlight.specular = new BABYLON.Color3(0.7, 0.7, 0.7);
				flashlight.range = 20;
				


			// Cámara
			/*
				var cameraArcRotative;
				camera = new BABYLON.ArcRotateCamera("CameraRotate", -Math.PI/2, Math.PI/2.2, 12, new BABYLON.Vector3(0, 3, 0), scene);
				camera.wheelPrecision = 15;
				camera.lowerRadiusLimit = 0.0001;
				camera.upperRadiusLimit = 22;
				scene.activeCamera = camera;
				camera.attachControl(canvas);
				camera.keysUp = [];
				camera.keysDown = [];
				camera.keysLeft = [];
				camera.keysRight = [];
				camera.checkCollisions=true;
*/
                //Cámara que sigue al jugador
				var camera = new BABYLON.FollowCamera("FollowCam", new BABYLON.Vector3(0, -1, -5), scene);
				camera.target = meshPlayer; // target any mesh or object with a "position" Vector3
				camera.maxCameraSpeed = 20;
				camera.applyGravity = true;
				camera.radius = -3.5;
				camera.heightOffset = 0.5;
				camera.keysUp = [];
				camera.keysDown = [];
				camera.keysLeft = [];
				camera.keysRight = [];
				scene.activeCamera = camera;

                //Cámara desde arriba
				var topDownCamera = new BABYLON.FollowCamera("TopDownCam", new BABYLON.Vector3(0, 0, 0), scene);
				topDownCamera.position.y = topDownCameraHeight;
				topDownCamera.target = meshPlayer;
				topDownCamera.heightOffset = topDownCameraHeight;
				topDownCamera.radius = -0.1;
				topDownCamera.keysUp = [];
				topDownCamera.keysDown = [];
				topDownCamera.keysLeft = [];
				topDownCamera.keysRight = [];


            // Material

				var invisible = new BABYLON.StandardMaterial("default", scene);
				invisible.alpha = 0.1;


			// Ground
				var plane = BABYLON.Mesh.CreatePlane("Ground", planeSize, scene);
				var materialPlane = new BABYLON.StandardMaterial("Baldosa", scene);
				materialPlane.diffuseTexture = new BABYLON.Texture("images/BaldosaReplicada.png", scene);
            /*
                //Única baldosa 				
                    materialPlane.diffuseTexture.uScale = (planeSize * 4) / 10;
				    materialPlane.diffuseTexture.vScale = (planeSize * 4) / 10;
            */
                //Múltiples baldosas
				    materialPlane.diffuseTexture.uScale = planeSize / 7.5;
				    materialPlane.diffuseTexture.vScale = planeSize / 7.5;
				plane.rotation.x = Math.PI / 2;
				plane.position.y = alturaSuelo;
				plane.material = materialPlane;

            // Ceiling
				var ceiling = BABYLON.Mesh.CreatePlane("Ceiling", planeSize, scene);
				var materialCeiling = new BABYLON.StandardMaterial("Celda", scene);
				materialCeiling.diffuseTexture = new BABYLON.Texture("images/Baldosa.png", scene);
                //Múltiples baldosas
				    materialCeiling.diffuseTexture.uScale = planeSize / 3;
				    materialCeiling.diffuseTexture.vScale = planeSize / 3;
				ceiling.rotation.x = -Math.PI / 2;
				ceiling.position.y = alturaSuelo + alturaMuro;
				ceiling.material = materialCeiling;
               // ceiling.rotation.

            // Collisions

				scene.collisionsEnabled = true;
				scene.gravity = gravity;

				plane.checkCollisions = true;


			// Shadows

				/*var shadowGenerator = new BABYLON.ShadowGenerator(2048, flashlight);
				shadowGenerator.useVarianceShadowMap = true;
                */
				
				
				//while(walls[auxi][auxj] != WallState.Alive){ if(auxi>=lastCol) {auxi=0;auxj++;} else auxi++;}
				/*shadowGenerator.getShadowMap().renderList.push(walls[auxi][auxj]);
				plane.receiveShadows = true;
                */


			window.addEventListener("keypress", function (evt) {
			    if (!scene)
			        return;
			    if (evt.keyCode == 102) {
			        if (activeFlashlight)
			            flashlight.setEnabled(0);
			        else flashlight.setEnabled(1);
			        activeFlashlight = !activeFlashlight;

			    }
			    if (evt.keyCode == 99) {
			        activeCamera = (activeCamera + 1) % numCameras;
			        switch (activeCamera) {
			            case 0:
			                scene.activeCamera = camera;
			                break;
			            case 1:
			                scene.activeCamera = topDownCamera;
			                break;
			            default:
			                break;
			        }
			    }
			});
			window.addEventListener("keydown", function (evt) {

				if (!scene)
					return;

				//console.log(evt.keyCode);

				if (evt.keyCode == 32) {

				}
				//Key LEFT
				if (evt.keyCode == 37 || evt.keyCode == 65) {
					turnLeft = true;
					turnRight = false;
				}

				//Key RIGHT
				if (evt.keyCode == 39 || evt.keyCode == 68) {
					turnLeft = false;
					turnRight = true;
				}
				//Key UP
				if (evt.keyCode == 38 || evt.keyCode == 87) {
					forward = true;
					backwards = false;

				}
				//Key BACK
				if (evt.keyCode == 40 || evt.keyCode == 83) {
					backwards = true;
					forward = false;
				}
                //Key Control
				if (evt.keyCode == 17) {
				    if (!crouching && !jumping) {
				        CrouchAnimation();
				        speed = speed * speedReduceCrouching;
				        crouching = true;
				    }
				}
			    //Key Shift
				if (evt.keyCode == 16) {
				}
			    //Key Space
				if (evt.keyCode == 32) {
				    if (!jumping && !crouching) {
				        jumping = true;
				        JumpAnimation();
				        window.setTimeout(Land, jumpTime * 1000);
				    }
				}

			});

			window.addEventListener("keyup", function (evt) {

			    if (evt.keyCode == 37 || evt.keyCode == 39 || evt.keyCode == 65 || evt.keyCode == 68) {
					turnLeft = false;
					turnRight = false;
				}

			    if (evt.keyCode == 38 || evt.keyCode == 40 || evt.keyCode == 87 || evt.keyCode == 83) {
					forward = false;
					backwards = false;
				}
				if (evt.keyCode == 17) {
				    speed = speed / speedReduceCrouching;
				    StandUpAnimation();
				}
			});


			//BeforeREnder
			scene.registerBeforeRender(function(){
				if(scene.isReady() && meshPlayer) {
					if (turnLeft) {
						collidingBox.rotation.y -= 0.05;
					} else if (turnRight) {
						collidingBox.rotation.y += 0.05;
					}
					var vel,velZ,velX;
					if(forward){
						velZ = Math.cos(collidingBox.rotation.y)*speed;
						velX = Math.sin(collidingBox.rotation.y)*speed;
						vel = gravity.add(new BABYLON.Vector3(velX, 0, velZ));
						collidingBox.moveWithCollisions(vel);
					}
					else
						if(backwards){
							velZ = Math.cos(collidingBox.rotation.y)*backSpeed;
							velX = Math.sin(collidingBox.rotation.y)*backSpeed;
							vel = gravity.add(new BABYLON.Vector3(velX, 0, velZ));
							collidingBox.moveWithCollisions(vel);
						}

					meshPlayer.position = collidingBox.position;
					meshPlayer.rotation = collidingBox.rotation;
					meshPlayer.scaling = collidingBox.scaling;
					flashlight.position = collidingBox.position;
					flashlight.direction = new BABYLON.Vector3(Math.sin(collidingBox.rotation.y), angFlashlight, Math.cos(collidingBox.rotation.y))
					topDownCamera.rotation.y = meshPlayer.rotation.y;
				}

			});

            // Render loop
            var renderLoop = function () {
                // Start new frame
                engine.beginFrame();

                scene.render();
				window.document.title = BABYLON.Tools.GetFps().toFixed() + " fps";
                // Present
                engine.endFrame();


                // Register new frame
                BABYLON.Tools.QueueNewFrame(renderLoop);
            };


            BABYLON.Tools.QueueNewFrame(renderLoop);
        }

    </script>
</body>
</html>