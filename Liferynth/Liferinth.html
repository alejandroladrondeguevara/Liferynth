<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
    <meta charset="utf-8">
    <title>Liferinth.js</title>
    <script src="js/babylon.js"></script>
    <script src="js/hand.js"></script>
    <script src="js/Walls.js"></script>
    <script src="js/Player.js"></script>
    <script src="js/Enemies.js"></script>
    <script src="js/Enemy.js"></script>
    <script src="js/WebCLFunctions.js"></script>
    <script src="js/LiferinthFunctions.js"></script>
    <script src="js/exitArrow.js"></script>
    <script src="js/Cameras.js"></script>
    <style>
        html, body {
            width: 100%;
            height: 100%;
            padding: 0;
            margin: 0;
            overflow: hidden;
        }

        #renderCanvas {
            width: 100%;
            height: 100%;
        }
    </style>


    <!--Programa en WebCL -->
    <script id="life" type="x-kernel">
        __kernel void life(
        __global uchar* input,
        __global uchar* output,
        const uint count)
        {
            int i = get_global_id(0);
            output[i] = 0;
        }
    </script>


    <script>

        /** Global variables **/
        var cpu, gpu, speedSetting, rowsSettings, columnsSettings;
        //----------------------------------------------------------------------------------------------------
        /** Obtiene las variables que se pasan como parámetros en la URL **/
        function getUrlVars() {
            var vars = {};
            var parts = window.location.href.replace(/[?&]+([^=&]+)=([^&]*)/gi, function (m, key, value) {
                vars[key] = value;
            });
            return vars;
        }
        //-----------------------------------------------------------------------------------------------------
        /** Carga las opciones que previamente han sido seleccionadas en el menú **/
        function loadSettings() {
            cpu = getUrlVars()["C"];
            gpu = getUrlVars()["G"];
            speedSetting = getUrlVars()["S"];
            rowsSettings = getUrlVars()["R"];
            columnsSettings = getUrlVars()["Co"];

            /**
            Values
                cpu:				"green","red"
                gpu:				"green","red"
                speedSetting: 		"l"(Low),"n"(Normal),"h"(high)
                rowsSettings:  		"f"(Few),"n"(Normal),"m"(many)
                columns:			"f"(Few),"n"(Normal),"m"(many)
            **/
            if (cpu == "undefined") {
                cpu = "green";
                gpu = "green";
                speedSetting = "n"; 	//Normal
                rowsSettings = "n";		//Normal
                columnsSettings = "n";	//Normal
            }
        }
    </script>
</head>
<body onload="loadSettings()">
    <canvas id="renderCanvas"></canvas>
    <script>
        /*
        --------------------------
            Variables de WebCL
        --------------------------
        */
            var platforms; var platform;
            var devices; var device;
            var queue;
            var globalWorkSize; var localWorkSize; var workGroupSize;
            var kernelSource; var kernel;
          //Buffers y tamaños
            var DATA_SIZE = 0; var count = 0;
            var input; var output; var results; var data;

        if (window.webcl == undefined) {
            alert("Unfortunately your system does not support WebCL. " +
                  "Make sure that you have both the OpenCL driver " +
                  "and the WebCL browser extension installed.");
            }
        else if (BABYLON.Engine.isSupported()) {
            try {
                platforms = webcl.getPlatforms();
                alert("Excellent! Your system does support WebCL.");
            } catch (e) {
                alert("Unfortunately platform or device inquiry failed.");
            }

            loadSettings();
            //listDevices(platforms);

		    var canvas = document.getElementById("renderCanvas");
            var engine = new BABYLON.Engine(canvas, true);
            var scene = new BABYLON.Scene(engine);
            var imported = new BABYLON.Scene(engine);

			var meshPlayer, collidingBox,turnLeft=false,turnRight=false,forward=false,backwards=false;
			var jumping = false; var crouching = false;

			var rows;
			switch (rowsSettings) {
			    case "m":
			        rows = 40;
			        break;
			    case "n":
			        rows = 30;
			        break;
			    case "f":
			        rows = 20;
			        break;
			    default:
			        rows = 30;
			        break;
			}
			var lastRow = rows-2; //Por cómo está hecha la matriz, esta es la última fila de la matriz de muros
			var cols;
			switch (columnsSettings) {
			    case "m":
			        cols = 30;
			        break;
			    case "n":
			        cols = 20;
			        break;
			    case "f":
			        cols = 10;
			        break;
			    default:
			        cols = 20;
			        break;
			}
			var lastCol = cols - 1;
			var numWalls = 0;
            //Con 20x20 muros: Min 120, Max 200
			var auxX = (20 * 20) / 120;
			var auxY = (20 * 20) / 200;
			var minWalls = Math.floor((cols * rows) / auxX); 
			var maxWalls = Math.floor((cols * rows) / auxY);
            var exitRow = 0;
            var exitCol = Math.floor(cols / 2);
            var entranceRow = lastRow;
            var entranceCol = Math.floor(cols / 2);

			var timeChange;
			switch (speedSetting) {
			    case "h":
			        timeChange = 2;
			        break;
			    case "n":
			        timeChange = 4;
			        break;
			    case "l":
			        timeChange = 8;
			        break;
			    default:
			        timeChange = 4;
			        break;
			}

            var floorHeight = 0;            
			var offsetSize = 4;
			var planeWidthSize = (cols * offsetSize) + ((cols * offsetSize) / 2) - offsetSize;
			var planeDepthSize = (rows * offsetSize) - ((rows * offsetSize) / 4);
			var planeSize = planeDepthSize;

			var margin = 1.01;

			var gravity = new BABYLON.Vector3(0, -9, 0);

			var activeFlashlight = true;

			var _this = this;						

			var posMatrix;
			var paintedWalls;
			var walls;
			var binWalls;
			var totalWalls = rows*cols;
			var Walls = new Walls(_this);
			var wallScale = Walls.wallScale;
			var WallState = Walls.WallState;

			var enemies = []; // 0 enemigos inicialmente
			var numEnemies = 0;
			var Enemies = new Enemies(_this);

			posMatrix = Walls.PositionsMatrix(rows,cols);
			walls = Walls.RandomWallMatrix();
			Walls.CreateLabyrinthBounding(entranceCol, exitCol);
			Walls.GeneratePermaWalls();
            paintedWalls = Walls.PaintWalls(walls, rows, cols);
            Walls.AnimateWalls();
            Walls.HideWall(entranceRow, entranceCol);
            Walls.HideWall(exitRow,exitCol); //Los hemos creado porque puede levantarse más adelante, pero está levantado, hay que bajarlo

            Enemies.CreateEnemy((lastRow/2)-1, Math.floor(cols / 2));

            
            initWebCLKernel();
            //window.setInterval(ChangeWallsLife, timeChange * 1000);
            window.setInterval(runKernel, timeChange * 1000);

            //Jugador
			var Player = new Player(_this);
			Player.Initialize();
            //Luces

				//Hemisférica
				var light1 = new BABYLON.HemisphericLight("Hemi0", new BABYLON.Vector3(0, 1, 0), scene);
				light1.diffuse = new BABYLON.Color3(0.1, 0.1, 0.1);
				light1.specular = new BABYLON.Color3(0.2, 0.2, 0.2);
				light1.groundColor = new BABYLON.Color3(0, 0, 0);
                //Hemisférica 2
				var light2 = new BABYLON.HemisphericLight("Hemi0", new BABYLON.Vector3(0, -1, 0), scene);
				light2.diffuse = new BABYLON.Color3(0.1, 0.1, 0.1);
				light2.specular = new BABYLON.Color3(0.2, 0.2, 0.2);
				light2.groundColor = new BABYLON.Color3(0, 0, 0);

				//Spot
			    var angFlashlight = -0.4;
			    var flashlight = new BABYLON.SpotLight("Flashlight", new BABYLON.Vector3(meshPlayer.position.x, meshPlayer.position.y + (meshPlayer.scaling.y / 2) * margin, meshPlayer.position.z),
                    new BABYLON.Vector3(Math.sin(meshPlayer.rotation.y), angFlashlight, Math.cos(meshPlayer.rotation.y)), 3, 3, scene);
			        //new BABYLON.Vector3(-0.5, -0.2, 0.4), 3, 3, scene);
				flashlight.diffuse = new BABYLON.Color3(0.7, 0.7, 0.7);
				flashlight.specular = new BABYLON.Color3(0.7, 0.7, 0.7);
				flashlight.range = 20;				


            // Cámaras
				var Cameras = new Cameras(_this);
				Cameras.Initialize();

            // Material
				var invisible = new BABYLON.StandardMaterial("default", scene);
				invisible.alpha = 0.1;

			// Ground
				//var plane = BABYLON.Mesh.CreatePlane("Ground", planeSize, scene);
				var plane = BABYLON.Mesh.CreateGround("ground1", planeWidthSize, planeDepthSize, 2, scene);
				var materialPlane = new BABYLON.StandardMaterial("Baldosa", scene);
				materialPlane.diffuseTexture = new BABYLON.Texture("images/BaldosaReplicada.png", scene);
            /*
                //Única baldosa 				
                materialPlane.diffuseTexture.uScale = (planeSize * 4) / 10;
				materialPlane.diffuseTexture.vScale = (planeSize * 4) / 10;
            */
                //Múltiples baldosas
				materialPlane.diffuseTexture.uScale = planeSize / 7.5;
				materialPlane.diffuseTexture.vScale = planeSize / 7.5;				    
                
                //Ajuste posicional del "suelo"
				plane.position.x = paintedWalls[0][0].position.x + (planeWidthSize / 2) - offsetSize;
				plane.position.z = paintedWalls[0][0].position.z - (planeDepthSize / 2);
				plane.position.y = floorHeight;
				plane.material = materialPlane;

            // Ceiling
				//var ceiling = BABYLON.Mesh.CreatePlane("Ceiling", planeSize, scene);
				var ceiling = BABYLON.Mesh.CreateGround("ground1", planeWidthSize, planeDepthSize, 2, scene);
				var materialCeiling = new BABYLON.StandardMaterial("Celda", scene);
				materialCeiling.diffuseTexture = new BABYLON.Texture("images/Baldosa.png", scene);

                //Múltiples baldosas
				materialCeiling.diffuseTexture.uScale = planeSize / 3;
				materialCeiling.diffuseTexture.vScale = planeSize / 3;
                
                //Ajuste posicional del "cielo"
				ceiling.rotation.x = -Math.PI;
				ceiling.position.x = paintedWalls[0][0].position.x + (planeWidthSize / 2) - offsetSize;
				ceiling.position.z = paintedWalls[0][0].position.z - (planeDepthSize / 2);
				ceiling.position.y = floorHeight + Walls.wallScale.y;
				ceiling.material = materialCeiling;

            // Collisions
				scene.collisionsEnabled = true;
				scene.gravity = gravity;
				plane.checkCollisions = true;

			// Shadows

				/*var shadowGenerator = new BABYLON.ShadowGenerator(2048, flashlight);
				shadowGenerator.useVarianceShadowMap = true;
                */		
				
				//while(walls[auxi][auxj] != WallState.Alive){ if(auxi>=lastCol) {auxi=0;auxj++;} else auxi++;}
				/*shadowGenerator.getShadowMap().renderList.push(walls[auxi][auxj]);
				plane.receiveShadows = true;
                */

            // Dynamic world objects

                //Flecha que indica la dirección actual de la salida
				exitArrow(window, BABYLON, scene, meshPlayer, paintedWalls[exitRow][exitCol]);

            
			window.addEventListener("keydown", function (evt) {

				if (!scene)
					return;

				if (evt.keyCode == 70) {
				    if (activeFlashlight)
				        flashlight.setEnabled(0);
				    else flashlight.setEnabled(1);
				    activeFlashlight = !activeFlashlight;

				}
				
			    //console.log(evt.keyCode);

				//Key LEFT
				if (evt.keyCode == 37 || evt.keyCode == 65) {
					turnLeft = true;
					turnRight = false;
				}
				//Key RIGHT
				if (evt.keyCode == 39 || evt.keyCode == 68) {
					turnLeft = false;
					turnRight = true;
				}
				//Key UP
				if (evt.keyCode == 38 || evt.keyCode == 87) {
					forward = true;
					backwards = false;
				}
				//Key BACK
				if (evt.keyCode == 40 || evt.keyCode == 83) {
					backwards = true;
					forward = false;
				}
                //Key Control
				if (evt.keyCode == 17) {
				    if (!crouching && !jumping) {
				        Player.CrouchAnimation();
				        speed = speedReduceCrouching;
				        crouching = true;
				    }
				}
			    //Key Shift
				if (evt.keyCode == 16) {
				}
			    //Key Space
				if (evt.keyCode == 32) {
				    if (!jumping && !crouching) {
				        jumping = true;
				        Player.JumpAnimation();
				    }
				    //ChangeExit(true,false,1); //Cambia la salida de sitio				    
				}

			});

			window.addEventListener("keyup", function (evt) {

			    if (evt.keyCode == 37 || evt.keyCode == 39 || evt.keyCode == 65 || evt.keyCode == 68) {
					turnLeft = false;
					turnRight = false;
				}
			    if (evt.keyCode == 38 || evt.keyCode == 40 || evt.keyCode == 87 || evt.keyCode == 83) {
					forward = false;
					backwards = false;
				}
				if (evt.keyCode == 17) {
				    speed = defaultSpeed;
				    Player.StandUpAnimation();
				}
			});

			//BeforeRender
			scene.registerBeforeRender(function () {
			    if (scene.isReady() && meshPlayer) {
			        if (turnLeft)
			            Player.TurnLeft();
			        else if (turnRight) 
			            Player.TurnRight();
					
					if (forward)
					    Player.MoveForward();
					else if(backwards)
						Player.MoveBackwards();

					meshPlayer.position = collidingBox.position;
					meshPlayer.rotation = collidingBox.rotation;
					meshPlayer.scaling = collidingBox.scaling;
					flashlight.position = collidingBox.position;
					flashlight.direction = new BABYLON.Vector3(Math.sin(collidingBox.rotation.y), angFlashlight, Math.cos(collidingBox.rotation.y))

				}
			});

            // Render loop
            var renderLoop = function () {
                // Start new frame
                engine.beginFrame();

                scene.render();
                //window.document.title = BABYLON.Engine.getFps();//.GetFps().toFixed() + " fps";
                // Present
                engine.endFrame();

                // Register new frame
                BABYLON.Tools.QueueNewFrame(renderLoop);
            };

            BABYLON.Tools.QueueNewFrame(renderLoop);
        }

    </script>
</body>
</html>
